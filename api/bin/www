#!/usr/bin/env node
/*    Copyright 2016-2020 Firewalla Inc.
 *
 *    This program is free software: you can redistribute it and/or  modify
 *    it under the terms of the GNU Affero General Public License, version 3,
 *    as published by the Free Software Foundation.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU Affero General Public License for more details.
 *
 *    You should have received a copy of the GNU Affero General Public License
 *    along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

'use strict'

process.title = "FireApi"
process.setMaxListeners(0)
require('events').EventEmitter.prototype._maxListeners = 100;

const log = require("../../net2/logger.js")(__filename);

log.info("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++");
log.info("API Starting ");
log.info("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++");

// init FireRouter ASAP
const fireRouter = require('../../net2/FireRouter.js')

const sem = require('../../sensor/SensorEventManager.js').getInstance();

const bone = require("../../lib/Bone.js");

const f = require("../../net2/Firewalla.js");
const fc = require("../../net2/config.js");
initConfig()
async function initConfig() {
  await fc.initCloudConfig()  
}

// api/main/monitor all depends on sysManager configuration
const sysManager = require('../../net2/SysManager.js');

const rclient = require('../../util/redis_manager.js').getRedisClient()
const sclient = require('../../util/redis_manager.js').getSubscriptionClient()
const Message = require('../../net2/Message.js');

const platform = require('../../platform/PlatformLoader').getPlatform()

const http = require('http');
const i18n = require('i18n');

const PORT = normalizePort(process.env.PORT) || 8833;
const PORT_LOCAL_API = 8834;
const apiServers = {}

let language = 'en';

log.info("Waiting for cloud token...");

run0();

async function run0() {
  log.forceInfo("Waiting for first app to connect...");
  
  await sysManager.waitTillInitialized();
  if (bone.cloudready() &&
      bone.isAppConnected() &&
      fireRouter.isReady() &&
      // this is to ensure sysManager is already initliazed when called in API code
      sysManager.isConfigInitialized()) {
    log.info("Firewalla initialization complete");
    run();
  } else {
    setTimeout(()=>{
      sysManager.update(null);
      run0();
    },500);
  }
}

rclient.hget("sys:config", "language", (err, result) => {
  if(!err && result) {
    language = result;
  }

  log.info("Process is running in language " + language);

  i18n.configure({
    directory: __dirname + "/../../locales",
    defaultLocale: language
  });
});

async function run() {
  const app = require('../app.js');
  app.set('port', PORT);
  apiServers[PORT] = {}

  const appLocal = require('../app-local.js');
  appLocal.set('port', PORT_LOCAL_API);
  apiServers[PORT_LOCAL_API] = {}

  if (!platform.isFireRouterManaged()) {
    createServerAndListen(app, 'global', '0.0.0.0', PORT)
    if (!f.isProductionOrBetaOrAlpha())
      createServerAndListen(appLocal, 'global', '0.0.0.0', PORT_LOCAL_API)
    else
      createServerAndListen(appLocal, 'localhost', '127.0.0.1', PORT_LOCAL_API)
    return
  }

  sem.on(Message.MSG_SYS_NETWORK_INFO_RELOADED, () => {
    refreshListeningInterfaces(app)
    refreshListeningInterfaces(appLocal, true)
  })

  sclient.on("message", (channel, message) => {
    switch (channel) {
      case Message.MSG_SYS_API_INTERFACE_CHANGED:
        log.info('Message received', channel)
        refreshListeningInterfaces(app)
        refreshListeningInterfaces(appLocal, true)
        break
    }
  });
  sclient.subscribe(Message.MSG_SYS_API_INTERFACE_CHANGED)

  refreshListeningInterfaces(app)
  refreshListeningInterfaces(appLocal, true)
}

// policy:system => apiInterface has higher priority over firerouter interfaces change
// cloud socket should always be available whatever policy:system says
async function refreshListeningInterfaces(app, local = false) {
  log.info(`refreshing listening${local?' local':''} interfaces`)

  const userInterfaces = await getUserInterfaces()

  // local api always use monitoring interfaces
  const listeningInterfaces =
    local && f.isProductionOrBetaOrAlpha() ? [] :
    !userInterfaces ? sysManager.getMonitoringInterfaces() :
    userInterfaces.map(intf => sysManager.getInterfaceViaUUID(intf))
  log.debug(listeningInterfaces)

  const port = local ? PORT_LOCAL_API : PORT

  for (const uuid of Object.keys(apiServers[port])) {
    const currIntf = listeningInterfaces.find(i => i.uuid == uuid)
    if (
      // interface persists but ip changed
      currIntf && apiServers[port][uuid].ip != currIntf.ip_address
      ||
      // interface no longer exist
      !currIntf && uuid != 'localhost' && uuid != 'global'
    ) {
      stopServer(app, uuid, port)
    }
  }

  for (const intf of listeningInterfaces) {
    if (intf.ip_address)
      createServerAndListen(app, intf.uuid, intf.ip_address, port)
  }
  // always listen to localhost
  createServerAndListen(app, 'localhost', '127.0.0.1', port)
}

// Reading from policy:system directly to decouple from PolicyManager
async function getUserInterfaces() {
  try {
    const policyString = await rclient.hgetAsync('policy:system', 'apiInterface')
    if (!policyString) return null

    const policy = JSON.parse(policyString)
    return policy && policy.state ? policy.interfaces : null
  } catch(err) {
    log.error('Error reading policy:system => apiInterface', err)
    return null
  }
}

function createServerAndListen(app, uuid, ip, port) {
  try {
    if (apiServers[port][uuid]) return

    const server = http.createServer(app);

    log.info(`listen ${app.get('title')} on ${ip}:${port}`)
    server.listen(port, ip);
    server.on('error', onError);


    apiServers[port][uuid] = { server, ip }

  } catch(err) {
    log.error("Error creating FireAPI server", ip, port, err)
  }
}

function stopServer(app, uuid, port) {
  if (!apiServers[port] || !apiServers[port][uuid]) return
  const s = apiServers[port][uuid]

  try {
    log.info(`remove ${app.get('title')} on ${s.ip}:${port} intf:${uuid}`)
    s.server.close()
    delete apiServers[port][uuid]

  } catch(err) {
    log.error("Error removing", app.get('title'), uuid, s.ip, port, err)
  }
}


/**
 * Normalize a port into a number, string, or false.
 */

function normalizePort(val) {
  var port = parseInt(val, 10);

  if (isNaN(port)) {
    // named pipe
    return val;
  }

  if (port >= 0) {
    // port number
    return port;
  }

  return false;
}

/**
 * Event listener for HTTP server "error" event.
 */

function onError(error) {
  if (error.syscall !== 'listen') {
    throw error;
  }

  var bind = typeof PORT === 'string'
    ? 'Pipe ' + PORT
    : 'Port ' + PORT;

  // handle specific listen errors with friendly messages
  switch (error.code) {
    case 'EACCES':
      console.error(bind + ' requires elevated privileges');
      process.exit(1);
      break;
    case 'EADDRINUSE':
      console.error(bind + ' is already in use');
      process.exit(1);
      break;
    case 'EADDRNOTAVAIL':
      console.error(`${bind} is currently unavailable`);
      // no need to exit process for this error
      break;
    default:
      throw error;
  }
}

// for non production, just print on console
if((f.isProductionOrBeta())
  && !f.isDocker()) {
  process.on('uncaughtException',(err)=>{
    log.info("################### CRASH #############");
    log.info("+-+-+-",err.message,err.stack);
    if (err && err.message && err.message.includes("Redis connection")) {
      return;
    }
    bone.logAsync("error", {
      type: 'FIREWALLA.UI.exception',
      msg: err.message,
      stack: err.stack,
      err: err
    });
    setTimeout(()=>{
      process.exit(1);
    },1000*2);
  });
}

sem.on("ChangeLogLevel", (event) => {
  if(event.name && event.level) {
    if(event.name === "*") {
      require('../../net2/LoggerManager.js').setGlobalLogLevel(event.level);
    } else {
      require('../../net2/LoggerManager.js').setLogLevel(event.name, event.level);
    }
  }
});
